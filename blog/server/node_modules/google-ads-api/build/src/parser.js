"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRows = exports.getReportOptionFields = exports.getGAQLFields = exports.parse = exports.ParsingError = void 0;
var long_1 = __importDefault(require("long"));
var protos_1 = require("./protos");
var utils_1 = require("./utils");
exports.ParsingError = {
    NO_REPORT_OPTIONS_OR_GAQL_QUERY: "Must provided reportOptions or gaqlString to parse results.",
    NO_FIELDS_IN_GAQL_QUERY: "GAQL Query must contain at least one attribute, metric or segment.",
    NO_FIELDS_IN_REPORT_OPTIONS: "Report Options must contain at least one attribute, metric or segment.",
};
/**
  @description Parse the results of a query
  @example
  const parsedResults = parse({ results, reportOptions })
  const parsedResults = parse({ results, gaqlString })
*/
function parse(_a) {
    var results = _a.results, reportOptions = _a.reportOptions, gaqlString = _a.gaqlString;
    if (results.length === 0) {
        return results;
    }
    if (typeof reportOptions === "undefined" &&
        typeof gaqlString === "undefined") {
        throw new Error(exports.ParsingError.NO_REPORT_OPTIONS_OR_GAQL_QUERY);
    }
    var queryFields = reportOptions
        ? getReportOptionFields(reportOptions)
        : getGAQLFields(gaqlString);
    // Add in all relevant resource_name fields, which are always returned by API
    var entities = queryFields.map(function (field) { return field.split(".")[0]; });
    var resourceNameFields = protos_1.fields.resourceNames.filter(function (resourceNameField) {
        return entities.includes(resourceNameField.split(".")[0]);
    });
    var allFields = __spreadArrays(queryFields, resourceNameFields);
    return parseRows(results, allFields);
}
exports.parse = parse;
// This function assumes that a gaql query is of the format "select * * * from * ...".
// Queries that are not in this format should have thrown an error when called.
function getGAQLFields(gaqlString) {
    var normalisedQuery = utils_1.normaliseQuery(gaqlString);
    var fields = normalisedQuery
        .toLowerCase()
        .replace(/(^\s*select)|( from .*)|(\s+)/g, "")
        .split(",")
        .filter(function (field) { return field.length > 0; });
    if (!fields.length) {
        throw new Error(exports.ParsingError.NO_FIELDS_IN_GAQL_QUERY);
    }
    return fields;
}
exports.getGAQLFields = getGAQLFields;
function getReportOptionFields(reportOptions) {
    var fields = __spreadArrays((reportOptions.attributes || []), (reportOptions.metrics || []), (reportOptions.segments || []));
    if (!fields.length) {
        throw new Error(exports.ParsingError.NO_FIELDS_IN_REPORT_OPTIONS);
    }
    return fields;
}
exports.getReportOptionFields = getReportOptionFields;
function parseRows(rows, fields) {
    var fieldsPreSplit = {};
    // pre-split all the field strings for performance reasons (increases speed by ~5x for large number of rows)
    for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
        var field = fields_1[_i];
        fieldsPreSplit[field] = field.split(".");
    }
    var newRows = [];
    for (var r = 0; r < rows.length; r++) {
        var newRow = {};
        var originalRow = protos_1.services.GoogleAdsRow.fromObject(rows[r]);
        for (var split in fieldsPreSplit) {
            // @ts-expect-error These are the best we can do for these types
            var _a = fieldsPreSplit[split], parent_1 = _a[0], children = _a.slice(1);
            // Ignore null fields (unspecified resource names)
            if (!originalRow[parent_1]) {
                continue;
            }
            newRow[parent_1] = parseNestedValues(newRow[parent_1], originalRow[parent_1], parent_1, children);
        }
        newRows.push(newRow);
    }
    return newRows;
}
exports.parseRows = parseRows;
function parseNestedValues(row, data, field, paths) {
    if (!data)
        return null;
    var parentField = paths[0], childFields = paths.slice(1);
    if (!row)
        row = {};
    if (childFields.length === 0) {
        var rawVal = data[parentField];
        var parsedVal = long_1.default.isLong(rawVal)
            ? new long_1.default(rawVal.low, rawVal.high, rawVal.unsigned).toNumber()
            : rawVal;
        row[parentField] = parsedVal;
        return row;
    }
    row[parentField] = parseNestedValues(row[parentField], data[parentField], parentField, childFields);
    return row;
}
